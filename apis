QUEUE
------
priority_queue<int,<vi(optioal)>,greater<int(optional)> > pq;
pq.push()
pq.top()
pq.pop()

HEAP
---------
maxheap ==> less<int>()
minheap ==> greater<int>()
make_heap(all(vec),greater<int>()) ==> minheap
vec.push_back(ele) and push_heap(all(vec),greater<int>()) ==> pushing
ele=vec.front();pop_heap(all(vec),greater<int>());vec.pop_back() ==> poping

bitset
------
bitset<500> bt; 0 based
bt.set(2)
bt.flip(2) or bt.flip() all flip
br.count() number of set bits
br.reset() resets whole to zero
bt.test(i)
acess bt[i][j]
bt.any() any bit set
bt.none() none bit set


Priority Queue
--------------
Max priority queue ==> priority_queue<ii,vii,greater<ii> > pq;
Min priority queue ==> multiset <ii > pq;  

DP
--------
Minimum edit distance f(i,j) = min(f(i,j-1)+ca,
				   f(i-1,j)+cd,
				   f(i-1,j-1)+ct if(s[i-1]==s[j-1]) ct=0;
				   ) 
		       f(i,0)=i;f(0,j)=j;
LCS ==> f(i,j)=1+max(f(i,j-1),f(i-1,j)) if(s[i-1]==s[j-1]) f(i,j)=1+f(i-1,j-1)
LCSubstr = f(i,j) 1+f(i-1,j-1)	if(s1[i-1]==s2[j-1])
	   else 0
	   take max on every first update		
Egg Drop = 1+min(forxfloors max(f(x-1,e-1),f(n-x,e))
	  f(1,j)=1; f(i,1)=i;
LIS two loops i-> 1ton and j-> 1toi
LCA 
0/1 knapsack == (i,w) -- (i+1,w+wi) right to left
		      -- (i+1,w)
0/Inf knapsack == (i,w) -- (i,w+wi) left to right
			-- (i+1,w)

Maximum rectangle dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])

PHI and PILLAI
---------------
Pillai(n)=sum(k=1->n) (gcd(k,n)) = sum(d/n) (d*phi(n/d)) where d are divisiors of n
Phi(n) = prod(p/n) (n*(1-1/p)) where p are prime factors of n
void compute_phi()
{
  for(int i=1;i<=MAXV;i++)  phi[i]=i;
  for(int i=2;i<=MAXV;i++)
  {
    if(phi[i]==i)
    {
      for(int j=i;j<=MAXV;j+=i)
      {
        phi[j]-=phi[j]/i;
        phi[j]=mod(phi[j]);
      }
    }
  }
}
void compute_pillai()
{
  for(int i=1;i<=MAXV;i++)
  {
    for(int j=i;j<=MAXV;j+=i)
    {
      pil[j]+=i*phi[j/i];
      pil[j]=mod(pil[j]);
    }
  }
}
Comparator functions
---------------------
greater<int>()
greater_equal<int>()
less<int>()
less_equal<int>()
not_equal_to<int>()
less_equal<int>()
equal_to<int>()

SET
-------
vi a={1,2,4,5},b{4,5,6,7},c,d,e,f; (start1,end1,start2,end2,res)
set_union(all(a),all(b),back_inserter(c)) c={1,2,3,4,5,6,7}
set_intersection() ={4,5}
set_difference()   ={1,2}
set_symmetric_difference() ={1,2,6,7}  instead of vi for set<int> s1;use inserter(s1,s1.begin())

GRAPHS
------
I
--------
DETECTING CYCLES: BACK EDGES not !vis in dfs
BFS -> O(V+E) adj list else O(V2) shortest distance and all possibilites at particular distance and 0/1 bfs with weights 1
DFS -> O(V+E) adj list else O(V2) check all possibilites in one direction and no of connected components
MST -> minimum cost with n-1 edges with weights
SHORTEST PATHS -> can be done with bfs but with weights
	      -> Shortest path contains at most edges, because the shortest path couldn't have a cycle as the shortest path to all other vertices 			could be found without the need for a second visit for any vertices.
		TWO ALGOS
		1) KRUSKAL (ElogV) for sorting --> greedy edges smallest to largest edges with UDFS Data structure to check if nodes belong to same set
		2) Prims ((V+E)logV) logV because insertion into priority queue -->  greedy next nodes use priority queue to maintain the next least 				weighted edge and simliar to post bfs(POST!!?)
SSSP(Single Source Shortest Path) ==> 
		1) Bellmann ford O(V.E) if V=E2 then O(E3) --> only positive edges two loops 0 to n-1 and pairs of edges {wt,x,y} dist[y]>dist[x]+wt 				relax
		2) dijkstra normally O(V2) but with priority queue reduces to O(V+ElogV) --> similiar to prims instead of greedy edges greedy total 				distances using multiset as priority queue
ALL PAIR SHORTEST PATHS --> 
		1) Floyd Warshall O(V3) three loops ktoN itoN jtoN d[i][j]=min(d[i][j],d[i][k]+d[k][j])
FLOOD FILL  --> O(m.n)	
ARTICULATION POINTS AND BRIDGES: O(V+E) same as DFS or BFS No Bridge but can have articulation point but in bridge one of the nodes will be 					articulation point
				presence of a cycle indicates articulation point as the lowlink==id fails only when has 0 or 1 outgoind edges i.e root
eg] 1    3
     \  / 
       2   	Tree is composed of only bridges.. 3 types of edges 1)Fwd-tree edges of DFS 2)Back->same subtree ancestor 3)Cross->different subtree
     /   \														     (only in directed)
    4     5
BICONNECTED GRAPHS and COMPONENTS: Former is the graph which does not have articulation point i.e removing any of the nodes does not increase the 					   connected components in the graph.
				  Later is in which all connected components of the graph are biconnected (USE STACK!!) store u-v if an articulation 					point is found pop from stack until edges s it is found which consists all the edges forming one biconnected component

CONNECTED COMPONENTS --> strong conncectivity applies to only directed graphs
Strongly connected graphs and components : 
	1) TARJANS METHOD : O(V+E) for directed graphs find using Tarjans stack go on pushing until conditon lwlnk[s]==disc[s](similar to ap) and pop 					until s id found and make the lwlnk values oo so cross edges cannot be taken into consideration
	2) KOSARAJU O(V+E) two times dfs first or normal push elements onto stack after exploring all edges of that vertex and in second dfs on 			transposed graph pick element from stack if not visited and do dfs to get sccs
TOPOLOGICAL SORT : 1 ) Using BFS O(V+E) not visited and indegree zero push into queue and also into tsort array at front while poping from queue and 				also subtract indegrees from the poped vertex from the queue..For lexicographically toposrt use set or priority queue instead
		   2 ) Using DFS O(V+E) go on pushing onto the stack (or array) after exploring (reverse array )
BIPARTITE or two colorable: using bfs color source with one color next layer with other if any violations conclude not biparitie and bipartite graph 					has not odd cycle
II
---------
LCA(Least Common ANcestor Binary Uplifting ) table[k][i] k->2^kth jump i -> node 
table[i] can be computed using values from table[i-1] 
Uses --> root and find distance from node to node and also store min on path and jmp in powers of k and find min on path


III
-------
Tree Traversal trickery --> update and query values
MAX SUM PATH -> 4 cases 1) root NULL 0
			2) leaf root->data
			3) only one subtree present l+root->data or r+root->data
			4) both present update global max with l+r+root->data and continue searching with max(l,r)+root->data
Check If given is BST ;
        	if(!root)   				return true;

        	if(root->val>mx||root->val<mn||		return false;
           	root->left&&root->val==mn||
           	root->right&&root->val==mx)
        						return check(root->left,mn,root->val-1)&&check(root->right,root->val+1,mx);
Check If tree is symmetric or mirror
        if(p==NULL||q==NULL)    return p==q;
        return (p->val==q->val&&check(p->left,q->right)&&check(p->right,q->left));

MODULAR
---------
ANY NUMBER CAN BECOME VALID WHEN MODDED TOO
i.e Number of large ranges computer within the mods even divisibility test satisfy

BIT MANIP
---------
__builtin_popcount() --> number of set bits
divisibility by 3 --> number of oddbits set - number of even bits set should be divisible by 3 again recursion!!.

1)get the duplicate element 1,2,2,3
exor with 1 to n IMP--Bit set in resulting exor will be set atleast in one of the repeating numbers so seperate them into two groups by taking LSB x&=-x and then exor the arr[i] checking the bit set or not at rightmost got by x&-x


Arrays
--------
1) Max sum of subarr --> kadane go on summing and take max but when sm -ve reset to zero
Modified kadane for all -ve 
	resmx=curmx = a[0];
	for : i = 1 to size
	  curmx = max(a[i], curmx+a[i]);
	  resmx = max(resmx, curmx);
	return resmx
2) Maximum 2D subarr inlcusion and exclusion priciple a[x][y]-a[i-1][y]-a[x][j-1]+a[i-1][j-1]

SUBARR OR SUBSTRING -->  N^2
SUBSEQUENCE --> 2^N -1 (excluding empty )
SUBSET --> 2^N (including EMPTY SET )
PERMUTATIONS --> N! do{...}whilenext_permutation(all(str));
QUESTIONS
----------
why do u want to work for this company --> research abt company and products and what they do and what u have to offer
